#!/usr/bin/env bash
set -euo pipefail

VERSION="1.3.0"

# Prefer UTF-8 if not already set (avoid forcing a specific locale)
export LC_ALL="${LC_ALL:-en_US.UTF-8}"
export LANG="${LANG:-en_US.UTF-8}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
INPUT_DIR="."
OUTPUT_DIR="converted"
OVERWRITE=false
DRY_RUN=false
PRESERVE_METADATA=true

# Function to show help
show_help() {
    echo "ra2mp3 v$VERSION - Convert RealAudio files to MP3"
    echo
    echo "Usage: $0 [OPTIONS]"
    echo
    echo "Options:"
    echo "  -i, --input DIR      Input directory to recursively search for .ra files (default: current directory)"
    echo "  -o, --output DIR     Output directory for converted files (default: converted/)"
    echo "  --overwrite          Overwrite existing MP3 files"
    echo "  --strip-metadata     Strip metadata for smaller file sizes (default: preserve metadata)"
    echo "  --dry-run            Show what would be converted without actually converting"
    echo "  -v, --version        Show version information"
    echo "  -h, --help           Show this help message"
    echo
    echo "Description:"
    echo "  Recursively converts all .ra files in the input directory and"
    echo "  subdirectories to MP3 format. Output files are saved in the"
    echo "  specified output directory maintaining the original structure."
    echo
    echo "Examples:"
    echo "  $0                           Convert all .ra files in current directory and subdirectories"
    echo "  $0 --input /path/to/music    Convert files from specific directory"
    echo "  $0 --output /tmp/mp3s        Save converted files to specific location"
    echo "  $0 --overwrite               Overwrite existing MP3 files"
    echo "  $0 --strip-metadata          Strip metadata for smaller file sizes"
    echo "  $0 --dry-run                 Preview what would be converted"
    echo "  $0 --version                 Show version"
    echo
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|--version)
            echo "ra2mp3 v$VERSION"
            echo "Convert RealAudio (.ra) files to MP3 format"
            exit 0
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -i|--input)
            if [[ $# -lt 2 ]] || [[ -z "${2:-}" ]] || [[ "${2:-}" == -* ]]; then
                echo -e "${RED}Error: --input requires a directory argument${NC}"
                exit 1
            fi
            INPUT_DIR="$2"
            shift 2
            ;;
        -o|--output)
            if [[ $# -lt 2 ]] || [[ -z "${2:-}" ]] || [[ "${2:-}" == -* ]]; then
                echo -e "${RED}Error: --output requires a directory argument${NC}"
                exit 1
            fi
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --overwrite)
            OVERWRITE=true
            shift
            ;;
        --strip-metadata)
            PRESERVE_METADATA=false
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Check if ffmpeg is installed
if ! command -v ffmpeg &> /dev/null; then
    echo -e "${RED}Error: ffmpeg is not installed or not in PATH${NC}"
    echo "Please install ffmpeg first:"
    echo "  macOS: brew install ffmpeg"
    echo "  Ubuntu/Debian: sudo apt install ffmpeg"
    echo "  CentOS/RHEL: sudo yum install ffmpeg"
    exit 1
fi

# Validate input directory
if [[ ! -d "$INPUT_DIR" ]]; then
    echo -e "${RED}Error: Input directory '$INPUT_DIR' does not exist${NC}"
    exit 1
fi

# Convert INPUT_DIR to absolute path for consistency
INPUT_DIR=$(cd "$INPUT_DIR" && pwd)

# Count total files to convert (support common RealMedia extensions, case-insensitive)
total_files=$(find "$INPUT_DIR" -type f \( -iname '*.ra' -o -iname '*.ram' -o -iname '*.rm' \) | wc -l | tr -d ' ')

if [ "$total_files" -eq 0 ]; then
    echo -e "${YELLOW}No .ra files found in '$INPUT_DIR' and subdirectories.${NC}"
    exit 0
fi

echo -e "${BLUE}Found $total_files RealAudio files to convert${NC}"
if [[ "$DRY_RUN" == true ]]; then
    echo -e "${YELLOW}DRY RUN MODE - No files will be actually converted${NC}"
fi
echo -e "${BLUE}Input directory: $INPUT_DIR${NC}"
echo -e "${BLUE}Output directory: $OUTPUT_DIR${NC}"
if [[ "$PRESERVE_METADATA" == true ]]; then
    echo -e "${BLUE}Metadata: Preserving original file metadata (default)${NC}"
else
    echo -e "${BLUE}Metadata: Stripping metadata for smaller files${NC}"
fi
echo

# Initialize counters
current_file=0
converted_count=0
skipped_count=0
would_convert_count=0
failed_count=0

while IFS= read -r -d '' file; do
  current_file=$((current_file + 1))
  
  # Calculate relative path from input directory
  rel="${file#$INPUT_DIR/}"
  if [[ "$rel" == "$file" ]]; then
    # Handle case where file is directly in INPUT_DIR
    rel="$(basename "$file")"
  fi
  
  folder="$(dirname "$rel")"
  if [[ "$folder" == "." ]]; then
    folder=""
  fi
  # Determine base name without extension (handles .ra/.ram/.rm and case-insensitive)
  base_full="$(basename "$rel")"
  base="${base_full%.*}"
  
  # Construct output paths
  if [[ -n "$folder" ]]; then
    outdir="$OUTPUT_DIR/$folder"
  else
    outdir="$OUTPUT_DIR"
  fi
  outfile="$outdir/$base.mp3"

  # Create output directory only if not in dry-run mode
  if [[ "$DRY_RUN" != true ]]; then
    mkdir -p "$outdir"
  fi

  # Check if output file exists
  if [[ -f "$outfile" ]]; then
    if [[ "$OVERWRITE" != true ]]; then
      echo -e "${GREEN}[$current_file/$total_files] ‚úì Exists, skip: $outfile${NC}"
      skipped_count=$((skipped_count + 1))
      continue
    else
      echo -e "${YELLOW}[$current_file/$total_files] ‚ö† Overwriting: $outfile${NC}"
    fi
  fi

  if [[ ! -f "$file" ]]; then
    echo -e "${RED}[$current_file/$total_files] ‚úó Missing on disk: $file${NC}"
    continue
  fi

  # Show what would be done
  if [[ "$DRY_RUN" == true ]]; then
    echo -e "${BLUE}[$current_file/$total_files] üîç Would convert: $file ‚Üí $outfile${NC}"
    would_convert_count=$((would_convert_count + 1))
    continue
  fi

  echo -e "${BLUE}[$current_file/$total_files] ‚Üí Converting: $file ‚Üí $outfile${NC}"

  # Decide ffmpeg overwrite behavior
  if [[ "$OVERWRITE" == true ]]; then
    overwrite_flag=(-y)
  else
    overwrite_flag=(-n)
  fi

  # Decide metadata mapping behavior
  if [[ "$PRESERVE_METADATA" == true ]]; then
    metadata_flag=(-map_metadata 0)
  else
    metadata_flag=(-map_metadata -1)
  fi

  if ffmpeg -nostdin -hide_banner -loglevel error "${overwrite_flag[@]}" \
    -err_detect ignore_err \
    -i "$file" \
    -vn \
    "${metadata_flag[@]}" \
    -codec:a libmp3lame -q:a 2 \
    "$outfile"; then
    echo -e "${GREEN}[$current_file/$total_files] ‚úÖ Successfully converted: $outfile${NC}"
    converted_count=$((converted_count + 1))
  else
    echo -e "${RED}[$current_file/$total_files] ‚ùå Failed to convert: $file${NC}"
    failed_count=$((failed_count + 1))
  fi
done < <(find "$INPUT_DIR" -type f \( -iname '*.ra' -o -iname '*.ram' -o -iname '*.rm' \) -print0)

echo
if [[ "$DRY_RUN" == true ]]; then
  echo -e "${GREEN}üîç Dry run complete! Use without --dry-run to perform actual conversion.${NC}"
else
  echo -e "${GREEN}‚úÖ All done! Check $OUTPUT_DIR directory for your MP3 files.${NC}"
fi

# Summary
if [[ "$DRY_RUN" == true ]]; then
  echo -e "${BLUE}Summary:${NC} would_convert=$would_convert_count, skipped=$skipped_count, failed=$failed_count"
else
  echo -e "${BLUE}Summary:${NC} converted=$converted_count, skipped=$skipped_count, failed=$failed_count"
fi
